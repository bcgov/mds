
import datetime

from app.extensions import db
from sqlalchemy.dialects import postgresql
from sqlalchemy.schema import CreateIndex, CreateTable


def generate_history_table_migration(table):
    """
    Generates a flyway migration file that creates the history table for the specified table.
    The table you're generating the history table for must have a corresponding SQLAlchemy model with the __versioned__ = {} property defined.
    
    Make sure to review the output and adjust as necessary before running the migration.
    
    The command uses SQLAlchemy-continuum and built in SQLAlchemy model reflection to generate the history table definition.    
    """

    print(f'Generating history table definition for table: {table}')
    version_table_name = f'{table}_version'

    # Find the SQLAlchemy model for the table
    table_class = next((c for c in db.Model.registry.mappers if c.class_.__tablename__ == table), None)

    if table_class is None:
        print(f'Could not find SQLAlchemy model for table {table}')
        return

    # Find the SQLAlchemy-continuum version table for the table
    version_table_class = next((c for c in db.Model.registry.mappers if c.class_.__tablename__ == version_table_name), None)

    if version_table_class is None:
        print(f'Could not find SQLalchemy-continuum table definition for table {table}.')
        print(f'Ensure that the {str(table_class.class_)} model has the __versioned__ = {{}} property defined.')
        return

    version_table_definition = version_table_class.class_.__table__

    generate_version_table_migration(version_table_name, version_table_definition)
    generate_backfill_history_migration(table, version_table_name, table_class)

def generate_backfill_history_migration(table, version_table_name, table_class):
    data_migdt = (datetime.datetime.today() + datetime.timedelta(minutes=1)).strftime('%Y.%m.%d.%H.%M')
    migration_name = f'/migrations/sql/V{data_migdt}__add_{version_table_name}_history_table_backfill.sql'

    with open(migration_name, 'w') as f:
        table_columns = []

        for column in table_class.class_.__table__.columns:
            table_columns.append('"%s"' % column.name)

        
        # '0' for operation_type is an insert
        insert_stmt = 'with transaction AS (insert into transaction(id) values(DEFAULT) RETURNING id)\n' \
                'insert into {version_table_name} (transaction_id, operation_type, end_transaction_id, {table_columns})\n'\
                'select t.id, \'0\', null, {table_columns}\n' \
                'from {table},transaction t;\n' \
                .format(
                    table_columns=', '.join(table_columns),
                    table=table,
                    version_table_name=version_table_name
                )
        
        f.write("-- This file was generated by the generate_history_table_ddl command\n")
        f.write("-- The file contains the data migration to backfill history records for the {table} table\n")
        f.write(insert_stmt)

def generate_version_table_migration(version_table_name, version_table_definition):
    dt = datetime.datetime.today().strftime('%Y.%m.%d.%H.%M')

    migration_name = f'/migrations/sql/V{dt}__add_{version_table_name}_history_table.sql'

    version_table_create_statement = str(CreateTable(version_table_definition).compile(dialect=postgresql.dialect())).strip()

    with open(migration_name, 'w') as f:
        f.write("-- This file was generated by the generate_history_table_ddl command\n")
        f.write("-- The file contains the corresponding history table definition for the {table} table\n")
        f.write(version_table_create_statement)
        f.write(';\n')

        for index in version_table_definition.indexes:
            index_statement = str(CreateIndex(index).compile(dialect=postgresql.dialect())).strip()
            f.write(index_statement)
            f.write(';\n')



def generate_table_migration(table):
    """
    Generates a flyway migration file that creates a table for the specified SQLAlchemy model.
    
    Make sure to review the output and adjust as necessary before running the migration.
    
    The command uses SQLAlchemy-continuum and built in SQLAlchemy model reflection to generate the history table definition.    
    """

    print(f'Generating history table definition for table: {table}')

    # Find the SQLAlchemy model for the table
    table_class = next((c for c in db.Model.registry.mappers if c.class_.__tablename__ == table), None)

    if table_class is None:
        print(f'Could not find SQLAlchemy model for table {table}')
        return

    do_generate_table_migration(table, table_class.class_.__table__)


def do_generate_table_migration(table_name, table_definition):
    dt = datetime.datetime.today().strftime('%Y.%m.%d.%H.%M')

    migration_name = f'/migrations/sql/V{dt}__add_{table_name}_table.sql'

    create_table_statement = str(CreateTable(table_definition).compile(dialect=postgresql.dialect())).strip()

    with open(migration_name, 'w') as f:
        f.write("-- This file was generated by the generate_table_ddl command\n")
        f.write(f"-- The file contains the corresponding history table definition for the {table_name} table\n")
        f.write(create_table_statement)
        f.write(';\n')

        for index in table_definition.indexes:
            index_statement = str(CreateIndex(index).compile(dialect=postgresql.dialect())).strip()
            f.write(index_statement)
            f.write(';\n')
