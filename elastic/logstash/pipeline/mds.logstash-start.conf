input {
	#stdin {}

    # Default value is "$HOME/.logstash_jdbc_last_run"
    jdbc {
        jdbc_driver_library => "/usr/local/pgsql/share/java/postgresql-42.2.5.jar"
        jdbc_driver_class => "org.postgresql.Driver"
        jdbc_connection_string => "jdbc:postgresql://localhost:5432/mds?user=mds&password=test"
        jdbc_user => "mds"
        # parameters => { "favorite_artist" => "Beethoven" }
        schedule => "* * * * *"
        statement => "SELECT * FROM public.mine WHERE update_timestamp>:sql_last_value"
        use_column_value => true
        tracking_column => "update_timestamp"
        tracking_column_type => "timestamp"
    } 
}


    #   "mine_detail_guid" => "843a22df-9e85-4d2a-b9ad-56d962628921",
    #   "effective_date" => 2019-01-08T00:00:00.000Z,
    #          "mine_no" => "BLAH1451",
    #      "mine_region" => "SW",
    #        "mine_guid" => "68d486dc-7625-4f83-a771-777ca6843fe9",
    #   "major_mine_ind" => false,
    #      "update_user" => "DummyUser",
    #      "create_user" => "DummyUser",
    #         "@version" => "1",
    # "update_timestamp" => 2019-01-08T23:16:12.237Z,
    #        "mine_name" => "Hoyt",
    #        "mine_note" => "",
    # "create_timestamp" => 2019-01-08T23:16:12.237Z,
    #      "expiry_date" => 9999-12-31T00:00:00.000Z,
    #       "@timestamp" => 2019-01-10T06:29:21.906Z


## Add your filters / logstash plugins configuration here

filter {


    # # # Get the mine location
    # jdbc_streaming {
    #     jdbc_driver_library => "C:\Software\elastic\jdbc\postgresql-42.2.5.jar"
    #     jdbc_driver_class => "org.postgresql.Driver"
    #     jdbc_connection_string => "jdbc:postgresql://localhost:5432/mds?user=mds&password=test"
    #     jdbc_user => "mds"
    #     parameters => { "id" => "mine_guid"}
    #     statement => "SELECT latitude, longitude FROM public.mine_location WHERE mine_guid = :id"
    #     target => "[mine][coordinatestemp]"
        
    # }

    # if [mine][coordinatestemp] {
    #     mutate {
    #         add_field => { "[mine][location][lon]" => "%{[mine][coordinatestemp][0][longitude]}" }
    #         add_field => { "[mine][location][lat]" => "%{[mine][coordinatestemp][0][latitude]}" }
    #         remove_field => ["[mine][coordinatestemp]"]
    #     }
    # }

    # # Get the tenure code
    # jdbc_streaming {
    #     jdbc_driver_library => "C:\Software\elastic\jdbc\postgresql-42.2.5.jar"
    #     jdbc_driver_class => "org.postgresql.Driver"
    #     jdbc_connection_string => "jdbc:postgresql://localhost:5432/mds?user=mds&password=test"
    #     jdbc_user => "mds"
    #     parameters => { "id" => "mine_guid"}
    #     statement => "SELECT mine_tenure_type_code FROM public.mine_type WHERE mine_guid = :id"
    #     target => "[mine][tenuretemp]"
    # }

    # if [mine][tenuretemp] {
    #     mutate {
    #         add_field => { "[mine][tenure][code]" => "%{[mine][tenuretemp][0][mine_tenure_type_code]}" }
    #         remove_field => ["[mine][tenuretemp]"]
    #     }
    # }
    
    # if [mine][comoditytemp] {
    #     mutate {
    #         add_field => { "[mine][comodity][code]" => "%{[mine][comoditytemp][0][mine_commodity_code]}" }
    #         add_field => { "[mine][comodity][description]" => "%{[mine][comoditytemp][0][description]}" }
    #         remove_field => ["[mine][comoditytemp]"]
    #     }
    # }


    # # have to cast back to a string
    # mutate { add_field => [ "[@metadata][datehold]", "%{update_timestamp}"] }
    # date { match => [ "[@metadata][datehold]", "ISO8601" ] }

    # # Set the date of the event to the update time @timestamp = update time
    # date {
    #     match => [ "update_timestamp", "ISO8601"]
    # }   

}

output {
	
	stdout {}

	# elasticsearch {
	#  	hosts => "localhost:9200"
	# 	document_id => "%{[mine_detail_guid]}"
	# 	index => "mds-mine-%{+YYYY.MM.dd}"
    #     template => "C:\git\elastic\logstash\kibana\template.json"
    #     template_name => "mds-mine-template"
	# }
}
