input {

  # stdin {}

  file {
    path => "/usr/share/logstash/monitor/*.log"
    start_position => "beginning"
  }

}
filter {

  # create hash from message to handle duplicates
  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MURMUR3"
  }

  if [path] =~ "access" {
    

    mutate {
      add_field => { "[log][type]" => "access" }
    }
    
    grok {
      match => { "message" => ["%{IPORHOST:[nginx][access][remote_ip]} - %{DATA:[nginx][access][user_name]} \[%{HTTPDATE:[nginx][access][time]}\] \"%{WORD:[nginx][access][method]} %{DATA:[nginx][access][url]} HTTP/%{NUMBER:[nginx][access][http_version]}\" %{NUMBER:[nginx][access][response_code]} %{NUMBER:[nginx][access][body_sent][bytes]} \"%{DATA:[nginx][access][referrer]}\" \"%{DATA:[@metadata][jwt]}\" \"%{DATA:[nginx][access][agent]}\" \"%{IPORHOST:[nginx][access][client_ip]}\" \"%{GREEDYDATA:[nginx][access][payload]}\""] }
      remove_field => "message"
    }
    mutate {
      add_field => { "read_timestamp" => "%{@timestamp}" }
    }
    date {
      match => [ "[nginx][access][time]", "dd/MMM/YYYY:H:m:s Z" ]
      remove_field => "[nginx][access][time]"
    }
    useragent {
      source => "[nginx][access][agent]"
      target => "[nginx][access][user_agent]"
      remove_field => "[nginx][access][agent]"
    }
    geoip {
      source => "[nginx][access][remote_ip]"
      target => "[nginx][access][geoip]"
    }

    geoip {
      source => "[nginx][access][client_ip]"
      target => "[nginx][access][server][geoip]"
    }


    # decode JWT
    if [@metadata][jwt] {

      mutate {
        split => { "[@metadata][jwt]" => "." }
      }

      mutate {
        copy => { "[@metadata][jwt][1]" => "[@metadata][b64]" }
      }

      ruby {
        init => "require 'base64'"
        code => "event.set('[@metadata][jwt_decoded]', Base64.decode64(event.get('[@metadata][b64]')))"
      }

      json {
        source => "[@metadata][jwt_decoded]"
        target => "jwt_data"
      }
    }

    }

    if [nginx][access][payload] {
      # remove \ from payload
      mutate {
        gsub => [
          "[nginx][access][payload]", "[\\]", ""
        ]
      }

      # parse json to data field
      json {
        source => "[nginx][access][payload]"
        target => "[data]"
      }
    }


    # Get the type of operation of interest

    mutate {
      add_field => { "[@metadata][action]" => "%{[nginx][access][method]} %{[nginx][access][url]}" }
    }

    # Get the operation
    translate {
      field => "[@metadata][action]"
      destination => "operation"
      dictionary_path => "/usr/share/logstash/dictionaries/action.yml"
      fallback => "other"
      regex => true
    }

    # Extract mine guid based on operation
    if [operation] != "other" {
      grok {
        match => { "[nginx][access][url]" => [".*/api/mines/%{UUID:[mine][id]}", ".*/api/documents/mines/%{UUID:[mine][id]}"] }
      }

      # lookup by mine id
      jdbc_streaming {
        jdbc_driver_library => "/usr/share/logstash/jdbc/postgresql-42.2.5.jar"
        jdbc_driver_class => "org.postgresql.Driver"
        jdbc_connection_string => "${JDBC_CONNECTION_STRING}"
        jdbc_user => "${JDBC_USER}"
        jdbc_password => "${JDBC_PASSWORD}"
        statement => "SELECT mi.mine_region as numero, ml.latitude as lat, ml.longitude as lon, mi.mine_no as numero, mi.mine_name as name FROM mine mi JOIN mine_location ml ON ml.mine_guid = mi.mine_guid WHERE mi.mine_guid = :mine_id;"
        parameters => { "mine_id" => "[mine][id]"}
        target => "mine_data"
      }


      if [mine_data] {
        mutate {
          rename => { "[mine_data][lat]" => "[mine_data][location][lat]" }
        }
        mutate {
          rename => { "[mine_data][lon]" => "[mine_data][location][lon]" }
        }
      }

      if [nginx][access][referrer] {
        translate {
          field => "[nginx][access][referrer]"
          destination => "[mds][group]"
          dictionary_path => "/usr/share/logstash/dictionaries/group.yml"
          regex => true
          fallback => 'other'
          exact => true
        }
      }

    }
  }
  else if [path] =~ "error" {

    mutate {
      add_field => { "[log][type]" => "error" }
    }

    grok {
      match => { "message" => ["%{DATA:[nginx][error][time]} \[%{DATA:[nginx][error][level]}\] %{NUMBER:[nginx][error][pid]}#%{NUMBER:[nginx][error][tid]}: (\*%{NUMBER:[nginx][error][connection_id]} )?%{GREEDYDATA:[nginx][error][message]}"] }
      remove_field => "message"
    }
    mutate {
      rename => { "@timestamp" => "read_timestamp" }
    }
    date {
      match => [ "[nginx][error][time]", "YYYY/MM/dd H:m:s" ]
      remove_field => "[nginx][error][time]"
    }
  }
}


output {
  
  # stdout {}

  elasticsearch {
    hosts => "${ES_HOST}"
    user => "${ES_USER}"
    password => "${ES_PASSWORD}"
    index => "mds-nginx-%{[log][type]}-%{+YYYY.MM.dd}"
    document_id => "%{[@metadata][fingerprint]}"
    template => "/usr/share/logstash/templates/mds.nginx.template.json"
    template_name => "mds-nginx"
  }

}